def simple_num_gen(start,stop):
    r=[]
    for i in range (start,stop,1):
         for v in range(2,i):
            if  i%v==0:
                break
         else:
             r.append(i) 
    return (r.reverse())       
          
                
        

def mirrow(start_power,reduce_digit=False):
     # Ecли симметрична
    v=str(start_power).__len__()- reduce_digit
    if v%2==0:
       digit=int(v/2)
       
       base=range(10**(digit-1),10**digit)
       simmetry=None
    else:
       digit=int(v/2)
       base=range(10**(digit-1),10**digit)
       simmetry=True
    return(base,simmetry)  


def polindrome_str(stop,start,n=1,step=0):
    pList=[]
    stop_power=stop**2
    start_power=start**2
    base,simmetry = mirrow(start_power)
    polindrome=start**2
  
    while n<len(base) and polindrome>stop_power:

        if polindrome> stop_power and n>=len(base) and simmetry==True:
           simmetry=False
           n=1

        if polindrome> stop_power  and n>=len(base): 
           v=polindrome/10
           base,simmetry =mirrow(polindrome,True)
           n=1       
        if simmetry:
            part_non_symmetrical=base[-n]
            all_part=str(part_non_symmetrical)+str(9-step)+str(part_non_symmetrical)[::-1]
            step+=1
            if step == 10:
                n+=1
                step=0
      
        else:
            part_non_symmetrical=base[-n]
            all_part=str(part_non_symmetrical)+str(part_non_symmetrical)[::-1]
            #polindrome=int(all_part)  
            n+=1
        polindrome=int(all_part)     
        pList.append(polindrome)

   

    stop_val=pList[-1]
    stop_val1=pList[-1000]
               

    pass

polindrome_str(10,9999)

        

        
                      
        
                  
            
 
                           


 



